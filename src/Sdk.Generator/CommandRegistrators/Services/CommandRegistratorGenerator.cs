using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace Brighid.Commands.Sdk.Generator.CommandRegistrators
{
    /// <inheritdoc />
    public class CommandRegistratorGenerator : ICommandRegistratorGenerator
    {
        private readonly ISyntaxUtils syntaxUtils;
        private readonly ITypeUtils typeUtils;

        /// <summary>
        /// Initializes a new instance of the <see cref="CommandRegistratorGenerator"/> class.
        /// </summary>
        /// <param name="syntaxUtils">Utilities for working with Roslyn Syntaxes.</param>
        /// <param name="typeUtils">Utilities for working with types / type syntaxes.</param>
        public CommandRegistratorGenerator(
            ISyntaxUtils syntaxUtils,
            ITypeUtils typeUtils
        )
        {
            this.syntaxUtils = syntaxUtils;
            this.typeUtils = typeUtils;
        }

        /// <inheritdoc />
        public async Task<CompilationUnitSyntax> Generate(CommandContext context, CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            await Task.CompletedTask;

            var autoGeneratedCommentTrivia = Comment("// <auto-generated />");
            var codes = new ExpressionSyntax[] { ParseExpression("CS1591") };
            var ignoreWarningsTrivia = Trivia(PragmaWarningDirectiveTrivia(TokenConstants.DisableKeyword, SeparatedList(codes), true));

            var member = GenerateMember(context);
            return CompilationUnit()
                .AddMembers(member)
                .WithLeadingTrivia(TriviaList(autoGeneratedCommentTrivia, ignoreWarningsTrivia));
        }

        private MemberDeclarationSyntax GenerateMember(CommandContext context)
        {
            var @namespace = syntaxUtils.GetNamespaceOfClassDeclaration(context.ClassDeclaration);
            var classDeclaration = GenerateClass(context);

            return @namespace != null
                ? @namespace.AddMembers(classDeclaration)
                : classDeclaration;
        }

        private ClassDeclarationSyntax GenerateClass(CommandContext context)
        {
            var registratorBaseType = SimpleBaseType(TypeConstants.CommandRegistratorInterfaceType);
            var identifier = context.ClassDeclaration.Identifier.Text;
            var registerMethod = GenerateRegisterMethod(context);

            return ClassDeclaration($"{identifier}Registrator")
                .AddModifiers(TokenConstants.PublicModifier)
                .AddBaseListTypes(registratorBaseType)
                .AddMembers(registerMethod);
        }

        private MethodDeclarationSyntax GenerateRegisterMethod(CommandContext context)
        {
            var parameter = syntaxUtils.CreateParameter("Microsoft.Extensions.DependencyInjection.IServiceCollection", "services");
            var body = GenerateRegisterMethodBody(context);

            return MethodDeclaration(ParseTypeName("Brighid.Commands.Sdk.ICommandRunner"), ParseToken("Register"))
                .AddModifiers(TokenConstants.PublicModifier)
                .AddParameterListParameters(parameter)
                .AddBodyStatements(body.ToArray());
        }

        private IEnumerable<StatementSyntax> GenerateRegisterMethodBody(CommandContext context)
        {
            var classType = syntaxUtils.GetFullTypeName(context.ClassDeclaration);
            var inputType = syntaxUtils.GetImplementedBaseTypeArgumentName(context.SemanticModel, context.ClassDeclaration, "Brighid.Commands.Sdk.ICommand", 0);
            var startupTypeSymbol = typeUtils.GetNamedTypeArgument(context.AttributeData, "StartupType");
            var startupType = startupTypeSymbol?.ToDisplayString();

            var genericArguments = startupType == null
                ? $"{classType}, {inputType}"
                : $"{classType}, {inputType}, {startupType}";

            yield return ParseStatement($"return Brighid.Commands.Sdk.EmbeddedCommandRunnerFactory.Create<{genericArguments}>(services);");
        }
    }
}
